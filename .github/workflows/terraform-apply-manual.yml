name: Terraform Manual Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - production
          - staging
          - development
      directories:
        description: 'Specific directories to deploy (comma-separated, leave empty for all)'
        required: false
        type: string
        default: ''
      plan_only:
        description: 'Run plan only (no apply)'
        required: false
        type: boolean
        default: false
      auto_approve:
        description: 'Auto approve apply (skip manual approval)'
        required: false
        type: boolean
        default: false

env:
  TF_VERSION: '1.13.0'
  AWS_REGION: 'ap-northeast-2'
  TF_LOG: INFO

jobs:
  validate-inputs:
    name: Validate Inputs
    runs-on: ubuntu-latest
    outputs:
      can_auto_approve: ${{ steps.validate.outputs.can_auto_approve }}
    steps:
      - name: Validate auto-approve permission
        id: validate
        run: |
          # Production ÌôòÍ≤ΩÏùÄ auto_approve Î∂àÍ∞Ä
          if [[ "${{ inputs.environment }}" == "production" && "${{ inputs.auto_approve }}" == "true" ]]; then
            echo "::warning::Auto-approve is not allowed for production environment. Manual approval will be required."
            echo "can_auto_approve=false" >> $GITHUB_OUTPUT
          else
            echo "can_auto_approve=${{ inputs.auto_approve }}" >> $GITHUB_OUTPUT
          fi

  terraform-plan:
    name: Plan - ${{ inputs.environment }}
    needs: validate-inputs
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      plan_results: ${{ steps.plan.outputs.plan_results }}
      has_changes: ${{ steps.plan.outputs.has_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.environment == 'development' && secrets.AWS_ROLE_DEVELOPMENT || inputs.environment == 'staging' && secrets.AWS_ROLE_STAGING || secrets.AWS_ROLE_PRODUCTION }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: terraform-manual-${{ inputs.environment }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Determine directories
        id: dirs
        run: |
          if [ -n "${{ inputs.directories }}" ]; then
            # ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÄÏ†ïÌïú ÎîîÎ†âÌÜ†Î¶¨
            DIRS=""
            IFS=',' read -ra DIR_ARRAY <<< "${{ inputs.directories }}"
            for dir in "${DIR_ARRAY[@]}"; do
              dir=$(echo "$dir" | xargs)  # trim whitespace
              if [ -d "environments/${{ inputs.environment }}/$dir" ]; then
                DIRS="$DIRS environments/${{ inputs.environment }}/$dir"
              else
                echo "::warning::Directory not found: environments/${{ inputs.environment }}/$dir"
              fi
            done
          else
            # Î™®Îì† Terraform ÎîîÎ†âÌÜ†Î¶¨
            DIRS=$(find environments/${{ inputs.environment }} -name "*.tf" -type f -exec dirname {} \; | sort -u)
          fi

          echo "dirs<<EOF" >> $GITHUB_OUTPUT
          echo "$DIRS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "Directories to process:"
          echo "$DIRS"

      - name: Terraform Plan
        id: plan
        run: |
          PLAN_RESULTS=""
          HAS_CHANGES="false"
          PLAN_STATUS="success"

          while IFS= read -r dir; do
            [ -z "$dir" ] && continue

            echo "::group::Planning $dir"
            cd "${{ github.workspace }}/$dir"

            # Initialize
            terraform init -backend-config="key=${{ inputs.environment }}/$(basename $dir)/terraform.tfstate"

            # Format check
            terraform fmt -check=true -diff

            # Validate
            terraform validate

            # Plan
            set +e
            PLAN_OUTPUT=$(terraform plan -var-file="${{ inputs.environment }}.tfvars" -detailed-exitcode -out=tfplan 2>&1)
            EXITCODE=$?
            set -e

            # Exit codes: 0=no changes, 1=error, 2=changes
            if [ $EXITCODE -eq 2 ]; then
              HAS_CHANGES="true"
              STATUS="Changes detected"
            elif [ $EXITCODE -eq 0 ]; then
              STATUS="No changes"
            else
              PLAN_STATUS="failed"
              STATUS="Plan failed"
            fi

            # Save plan for apply
            if [ $EXITCODE -eq 2 ] || [ $EXITCODE -eq 0 ]; then
              # Upload plan as artifact
              mkdir -p /tmp/plans/$(basename $dir)
              cp tfplan /tmp/plans/$(basename $dir)/tfplan
            fi

            PLAN_RESULTS="$PLAN_RESULTS

          ### üìÅ Directory: \`$dir\`
          **Status:** $STATUS

          <details>
          <summary>Plan Output</summary>

          \`\`\`hcl
          $PLAN_OUTPUT
          \`\`\`

          </details>
          "

            echo "::endgroup::"
          done <<< "${{ steps.dirs.outputs.dirs }}"

          echo "plan_results<<EOF" >> $GITHUB_OUTPUT
          echo "$PLAN_RESULTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
          echo "status=$PLAN_STATUS" >> $GITHUB_OUTPUT

      - name: Upload plans
        if: steps.plan.outputs.has_changes == 'true' && inputs.plan_only == false
        uses: actions/upload-artifact@v3
        with:
          name: terraform-plans-${{ github.run_id }}
          path: /tmp/plans/
          retention-days: 1

      - name: Plan Summary
        run: |
          echo "## üìã Terraform Plan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Has Changes:** ${{ steps.plan.outputs.has_changes }}" >> $GITHUB_STEP_SUMMARY
          echo "**Plan Only Mode:** ${{ inputs.plan_only }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.plan.outputs.plan_results }}" >> $GITHUB_STEP_SUMMARY

  manual-approval:
    name: Manual Approval
    needs: [validate-inputs, terraform-plan]
    if: |
      needs.terraform-plan.outputs.has_changes == 'true' &&
      inputs.plan_only == false &&
      needs.validate-inputs.outputs.can_auto_approve == 'false'
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}-approval
    steps:
      - name: Request approval
        run: |
          echo "## ‚è∏Ô∏è Manual Approval Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Requested by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please review the plan above and approve to proceed with the deployment." >> $GITHUB_STEP_SUMMARY

  terraform-apply:
    name: Apply - ${{ inputs.environment }}
    needs: [validate-inputs, terraform-plan, manual-approval]
    if: |
      always() &&
      needs.terraform-plan.result == 'success' &&
      needs.terraform-plan.outputs.has_changes == 'true' &&
      inputs.plan_only == false &&
      (needs.manual-approval.result == 'success' || needs.validate-inputs.outputs.can_auto_approve == 'true')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    environment:
      name: ${{ inputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.environment == 'development' && secrets.AWS_ROLE_DEVELOPMENT || inputs.environment == 'staging' && secrets.AWS_ROLE_STAGING || secrets.AWS_ROLE_PRODUCTION }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: terraform-apply-${{ inputs.environment }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Download plans
        uses: actions/download-artifact@v3
        with:
          name: terraform-plans-${{ github.run_id }}
          path: /tmp/plans/

      - name: Determine directories
        id: dirs
        run: |
          if [ -n "${{ inputs.directories }}" ]; then
            DIRS=""
            IFS=',' read -ra DIR_ARRAY <<< "${{ inputs.directories }}"
            for dir in "${DIR_ARRAY[@]}"; do
              dir=$(echo "$dir" | xargs)
              if [ -d "environments/${{ inputs.environment }}/$dir" ]; then
                DIRS="$DIRS environments/${{ inputs.environment }}/$dir"
              fi
            done
          else
            DIRS=$(find environments/${{ inputs.environment }} -name "*.tf" -type f -exec dirname {} \; | sort -u)
          fi

          echo "dirs<<EOF" >> $GITHUB_OUTPUT
          echo "$DIRS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Terraform Apply
        id: apply
        run: |
          APPLY_RESULTS=""
          APPLY_STATUS="success"

          while IFS= read -r dir; do
            [ -z "$dir" ] && continue

            echo "::group::Applying $dir"
            cd "${{ github.workspace }}/$dir"

            # Initialize
            terraform init -backend-config="key=${{ inputs.environment }}/$(basename $dir)/terraform.tfstate"

            # Check if plan exists
            PLAN_FILE="/tmp/plans/$(basename $dir)/tfplan"
            if [ ! -f "$PLAN_FILE" ]; then
              echo "::warning::No plan file found for $dir, skipping"
              continue
            fi

            # Copy plan file
            cp "$PLAN_FILE" tfplan

            # Apply
            set +e
            APPLY_OUTPUT=$(terraform apply tfplan 2>&1)
            EXITCODE=$?
            set -e

            if [ $EXITCODE -ne 0 ]; then
              APPLY_STATUS="failed"
              echo "::error::Terraform apply failed for $dir"
            fi

            APPLY_RESULTS="$APPLY_RESULTS

          ### üìÅ Directory: \`$dir\`
          **Status:** $([ $EXITCODE -eq 0 ] && echo '‚úÖ Success' || echo '‚ùå Failed')

          <details>
          <summary>Apply Output</summary>

          \`\`\`
          $APPLY_OUTPUT
          \`\`\`

          </details>
          "

            echo "::endgroup::"
          done <<< "${{ steps.dirs.outputs.dirs }}"

          echo "apply_results<<EOF" >> $GITHUB_OUTPUT
          echo "$APPLY_RESULTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "status=$APPLY_STATUS" >> $GITHUB_OUTPUT


      - name: Apply Summary
        run: |
          echo "## üöÄ Terraform Apply Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ steps.apply.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.apply.outputs.apply_results }}" >> $GITHUB_STEP_SUMMARY

      - name: Create GitHub deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ inputs.environment }}',
              required_contexts: [],
              auto_merge: false,
              description: 'Manual terraform deployment'
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: '${{ steps.apply.outputs.status }}',
              environment_url: '${{ inputs.environment == 'development' && vars.ENVIRONMENT_URL_DEVELOPMENT || inputs.environment == 'staging' && vars.ENVIRONMENT_URL_STAGING || vars.ENVIRONMENT_URL_PRODUCTION }}',
              description: 'Terraform apply ${{ steps.apply.outputs.status }}'
            });